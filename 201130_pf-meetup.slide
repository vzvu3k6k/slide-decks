# 事業をグロースさせるためにエンジニアができること

プラットフォーム事業本部
本田 雄亮

2020年11月30日
PF-Meetup

## 自己紹介

## 本田 雄亮（Honda Yusuke）

- 所属：プラットフォーム事業本部 総合トップ開発部 PointClubチーム
- 入社年：2019年（新卒入社）
- Twitter: @yyh-gl
- 運営：DMM.go

.image ./images/logo.jpg _ 336

## DMM.go

DMM社内のGo活用事例を紹介

.link https://inside.dmm.com/entry/2020/02/03/dmmgo-1 第1回目
.link https://inside.dmm.com/entry/2020/02/03/dmmgo-2 第2回目

.image ./images/dmmgo_logo.png

## 今日話すこと

私が所属するPointClubチームにて、<br>
<u>事業をグロースさせていくために大事にしている考え</u>を主題に置き、\
**エンジニアとしてなにができるのか、実際なにをしているのか**を話します

## 開発体制

## PointClubチーム

- 開発スタイル：アジャイル
- チームメンバー：13名ほど
  - バックエンド：6名
  - ネイティブ，プロダクトデザイナー，グロース/マーケティング など

<br>

.image ./images/201130_pf-meetup/pointclub.png _ 550

## チームとして大事にしている考え

## "最短距離でリリース"

最短距離でのリリースを続けることで事業をグロースさせていく

.image ./images/201130_pf-meetup/leadtime.png _ 700

弊チームPOの石垣がiOSDCで発表

.link https://speakerdeck.com/i35_267/organizational-structure-to-maximize-the-development-process 組織構造の力学を操作して、アプリ開発プロセスを最大化させる

## エンジニアとしてできること

**スピード感ある開発**

- 手戻りをなくす
- 自動化

100%は無理でも最大限頑張る

## 手戻りをなくす

## 手戻りはだいたい認識差異から生まれる

例えば、、、
- 仕様の認識差異
  - 例：表示したい情報が違う
- 技術的な認識差異
  - 例：必要な情報がAPIレスポンスに含まれていない<br>
    と思ったら、使っている単語が違うだけでちゃんと渡してたり…

<br>

このような状況では、話し合いの場が必要になり、遅延が発生

一発でばしっと決められると嬉しい

では、なにをすればいいのか ▶▶▶

## 仕様の認識差異をなくす

## なぜ仕様の認識差異が生まれる？

仕様の認識差異は、チームメンバー間（特にPO↔エンジニア間）で、<br>
なぜそれを作っているのか、すなわち、目的が一致していない場合に発生しやすい

<br>

エンジニアがその機能を**なぜ**作っているのか明確に意識できていれば発生しづらい

<br>

さらに、目的を理解していれば副次効果として、各エンジニアから仕様部分での改善策が出てきやすくなる


## 目的を合わせるためにできること

<u>みんなでユーザーストーリーマッピングを作成</u>

ユーザーストーリーマッピング：<br>
どういう機能が必要か、どのタイミングで提供すべきかといった情報を <br>
ユーザーストーリー（≒ユーザーにとっての価値）に対応させて表現可能 <br>

## ユーザーストーリーマッピング

.image ./images/201130_pf-meetup/userstorymapping1.png _ 780

## ユーザーストーリーマッピング

.image ./images/201130_pf-meetup/userstorymapping2.png _ 780

## ユーザーストーリーマッピング

.image ./images/201130_pf-meetup/userstorymapping3.png _ 780

## ユーザーストーリーマッピング

.image ./images/201130_pf-meetup/userstorymapping4.png _ 780

## ユーザーストーリーマッピング

.image ./images/201130_pf-meetup/userstorymapping5.png _ 780

## ユーザーストーリーマッピングの恩恵

今作っている機能が、ユーザーのどういったストーリーに紐づくのかが明確になる

<br>

**→ 機能実装の目的が明確になるので、迷子になりにくい**


## より詳しい話はPO 石垣の発表をどうぞ

.image ./images/201130_pf-meetup/organizational_structure_to_maximize_the_development.png _ 780

.link https://speakerdeck.com/i35_267/organizational-structure-to-maximize-the-development-process 組織構造の力学を操作して、アプリ開発プロセスを最大化させる


## 技術的な認識差異をなくす

## 技術的な認識差異をなくすために

- 日常的な認識合わせ
- 廃らないドキュメント作り

## 日常的な認識合わせ

## API定義レビュー

API定義に変更があったときはクライアントとバックエンドの両メンバーでレビュー <br>

**クライアントとバックエンド間でAPI定義に関する認識が一致**

API定義にはOpenAPI（Swagger）を使用


.image ./images/201130_pf-meetup/design_review.png _ 900

## API定義を確認する方法

API定義はSwagger UIを通して確認可能

Swagger UI自体はS3でホスティングされており、いつでもアクセス可能 <br>
→ **いつでもチーム認識を確認可能**

.image ./images/201130_pf-meetup/swagger.png _ 750

## より詳細な話はこちら

API定義の共有については後ほど軽く説明しますが、<br>
詳細が以下のスライドに載っています

.image ./images/201130_pf-meetup/swagger_detail.png _ 500

.link https://speakerdeck.com/yyh_gl/develop-api-server-by-goa Goaを使ってAPIサーバ開発してみた

## デザインレビュー

みんなでデザインをレビュー

- 技術的に実現が難しい箇所を早期に発見できる
- クライアントとバックエンドの共通言語として利用できる
- 画面デザインを知ることで、自分がなにを作っているのかイメージしやすくなる
  - その画面専用のAPIにならないように注意
- 仕様の認識差異発見にも活躍
  
## Figma上でデザインを確認可能

.image ./images/201130_pf-meetup/figma_design.png _ 800

## みんなでレビューすることで…

みんなで認識合わせをする機会（仕組み）を作ることにより<br>
メンバー間の認識が大きくずれることをなくし、手戻りを防止

<br>

加えて、異なる領域のメンバーがレビューすることで、<br>
様々な視点からの意見がもらえる（品質向上）


## 技術的な認識差異をなくすために

- 日常的な認識合わせ
- 廃らないドキュメント作り

## 廃らないドキュメント作り

廃れたドキュメント＝現実とドキュメントの内容が乖離している状態 <br>
したがって、常に"現実"を基にドキュメントを作り続ければ廃れることはない

<br>

弊チームでは以下のドキュメントについて、<br>
コードを基に生成することで現実に則したドキュメントを生成

- API定義
- DBスキーマ定義

<br>

加えて、継続的にドキュメント生成する仕組み（生成自動化）により、<br>
ドキュメントの風化を防止


## 自動化

## 極力機械にやってもらう

- 人にしかできない作業に集中
- 人的ミスの排除

を目的として単純な反復作業は積極的に自動化

## API定義のドキュメント作成を自動化

下記タイミングで、CIにて、<br>
その時点の最新コードからopenapi.yamlを生成し、S3にアップロード

- 作業ブランチをPUSH
  - API定義に変更がある場合限定
- masterにPUSH（＝ STGリリース）

STGのAPI定義は常時閲覧可能

.image ./images/201130_pf-meetup/swagger_search.png _ 900


## DBスキーマ定義のドキュメント作成を自動化

[k1low/tbls](https://github.com/k1LoW/tbls)というツールを使用

<br>

下記のようなシンプルな設定ファイル `.tbls.yml` を作成し、

.code ./examples/201130_pf-meetup/.tbls.yml

コマンドを実行すると

.code ./examples/201130_pf-meetup/tbls

DBスキーマ定義がsvgおよびマークダウン形式で出力される ▶▶▶

## 生成物：テーブル一覧

.image ./images/201130_pf-meetup/tables.png _ 700

## 生成物：テーブル詳細

.image ./images/201130_pf-meetup/table.png _ 700

## 生成物：全テーブルの関連

.image ./images/201130_pf-meetup/relations.png _ 900

## 生成物：概要（README.md）

`README.md`にDB全体のスキーマ定義を出力

<br>

.image ./images/201130_pf-meetup/readme.png _ 1000


## DBスキーマ定義のドキュメントを共有

生成されたドキュメントは、<br>
アプリケーションコードとは別のGitHubリポジトリにPUSH

<br>

**ドキュメントはsvgおよびマークダウン形式なので、GitHubと相性が良い**

## リリースノート作成を自動化

リリース管理のために、PRDリリース時にリリースノートを作成している

作成自体は[goreleaser/goreleaser](https://github.com/goreleaser/goreleaser)により自動化

CIに組み込んでおり、タグPUSHをトリガーにリリースノートを生成

.image ./images/201130_pf-meetup/goreleaser.png _ 550


## 自動化により…

- 人にしかできない作業に集中
- 人的ミスの排除

といった先述の目的を満たすと同時に、廃れないドキュメントを実現


## まとめ

<u>**事業グロースのために最短距離でリリース**</u>

最短距離でリリースするための取り組みを紹介

- 認識差異をなくすための努力
  - みんなでユーザーストーリーマッピング作成
  - みんなでAPI定義レビュー
  - みんなでデザインレビュー
- 自動化
  - API定義のドキュメント化
  - テーブル定義のドキュメント化
  - リリース作業




## メモ

https://www.timakin.com/posts/hacker-and-suits

## 事業内容の理解

ある判断をするときに、事業について理解しているかどうかはとても重要<br>

<br><br>

事業を理解することのメリット
- 事業として進むべき道すじを理解できる<br>
  → 正しい判断ができる可能性が高まる
  - 例：新機能検討時に本当に必要かどうかを全員で議論可能
- 事業（ビジネス）に興味がわく
  - 全員がPOとなり、サービス改善のスピード向上

## 事業内容を理解するためにやっていること

- POによる事業説明会

<br>

- 他社内事業の確認<br>
  → 定期的に他社内事業のPLを起点に事業の特徴を確認
  - 他を知ることは自分たちの事業の理解を加速させる

<br>

**POだけでなくみんなで事業を作っていく姿勢**

## CIワークフロー（DEV）

1. feature→developにマージ
2. CI開始
   1. テスト（go test & Lint & セキュリティチェック）
   2. **DBスキーマ定義生成**
   3. DBスキーマ定義ファイル群を専用リポジトリ（GitHub）にPUSH
   3. **Swagger（openapi.yaml）生成（API定義レビュー用）**
   4. 3の生成物をS3にアップロード
   5. develop→masterマージ用PR生成/更新
3. CDへ続く


## CIワークフロー（STG）

1. develop→masterにマージ
2. CI開始
   1. テスト（go test & Lint & セキュリティチェック）
   2. **Swagger（openapi.yaml）生成（マスター情報/ドキュメント用）**
   3. 2の生成物をS3にアップロード
3. CDへ続く

## CIワークフロー（PRD）

1. タグを打ってPUSH
2. CI開始
   1. テスト（go test & Lint & セキュリティチェック）
   2. リリースノート（draft）生成
   3. 承認待ち状態に遷移
3. リリースノートで差分を確認してpublish
4. 2-3を承認
5. CDへ続く

## CDワークフロー

1. ECRにコンテナイメージをPUSH
2. ECSのタスク定義作成
3. Blue/Greenデプロイ開始
4. QA用アプリを通して新コンテナの動作確認
   - 公開されているアプリは旧コンテナにリクエスト
5. 3-4が問題なければECSのコンテナ入れ替え
